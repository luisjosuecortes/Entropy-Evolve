[{"instance_id": "django__django-12497", "model_patch": "```diff\ndiff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -128,7 +128,36 @@ class ThroughModel(models.Model):\n             ),\n         ])\n \n-    def test_ambiguous_relationship_model(self):\n+    def test_ambiguous_relationship_model_from(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField('Person', through='AmbiguousRelationship')\n+\n+        class AmbiguousRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_group = models.ForeignKey(Group, models.CASCADE, related_name='first')\n+            second_group = models.ForeignKey(Group, models.CASCADE, related_name='second')\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.field', but it has more than one \"\n+                \"foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n+\n+    def test_ambiguous_relationship_model_to(self):\n \n         class Person(models.Model):\n             pass\n@@ -152,7 +181,7 @@ class AmbiguousRelationship(models.Model):\n                 \"keyword argument.\",\n                 hint=(\n                     'If you want to create a recursive relationship, use '\n-                    'ForeignKey(\"self\", symmetrical=False, through=\"AmbiguousRelationship\").'\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n                 ),\n                 obj=field,\n                 id='fields.E335',\n```", "model_name_or_path": "model-2"}, {"instance_id": "django__django-12308", "model_patch": "```diff\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -223,6 +223,11 @@ def display_for_field(value, field, empty_value):\n     if value is None or value == '':\n         return empty_value\n     \n+    if isinstance(field, models.JSONField):\n+        return field.prepare_value(value)\n+\n     if isinstance(value, dict):\n         return str(value)\n     \n```", "model_name_or_path": "model-2"}, {"instance_id": "pylint-dev__pylint-7114", "model_patch": "```diff\ndiff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py\n--- a/pylint/checkers/imports.py\n+++ b/pylint/checkers/imports.py\n@@ -200,7 +200,11 @@\n         # Filter to avoid absolute paths and module conflicts\n         for path in self._paths:\n             modname = self._get_module_name(path)\n-            if os.path.exists(os.path.join(path, '__init__.py')) or modname != module:\n+            if modname == module:\n+                # If the module name matches the package, continue to next path\n+                continue\n+            if os.path.exists(os.path.join(path, '__init__.py')):\n                 paths.append(path)\n \n         return paths\n```", "model_name_or_path": "model-2"}, {"instance_id": "matplotlib__matplotlib-25311", "model_patch": "```diff\ndiff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,6 +1,7 @@\n from io import BytesIO\n import ast\n import pickle\n+import pickletools\n \n import numpy as np\n import pytest\n@@ -88,6 +89,7 @@ def _generate_complete_test_figure(fig_ref):\n \n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n+    plt.legend(draggable=True)\n \n \n @mpl.style.context(\"default\")\n@@ -95,9 +97,13 @@ def _generate_complete_test_figure(fig_ref):\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n     # plotting is done, now test its pickle-ability\n-    pkl = BytesIO()\n-    pickle.dump(fig_ref, pkl, pickle.HIGHEST_PROTOCOL)\n-    loaded = pickle.loads(pkl.getbuffer())\n+    pkl = pickle.dumps(fig_ref, pickle.HIGHEST_PROTOCOL)\n+    # FigureCanvasAgg is picklable and GUI canvases are generally not, but there should\n+    # be no reference to the canvas in the pickle stream in either case.  In order to\n+    # keep the test independent of GUI toolkits, run it with Agg and check that there's\n+    # no reference to FigureCanvasAgg in the pickle stream.\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+    loaded = pickle.loads(pkl)\n     loaded.canvas.draw()\n \n     fig_test.set_size_inches(loaded.get_size_inches())\n```", "model_name_or_path": "model-2"}, {"instance_id": "django__django-14534", "model_patch": "```diff\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -99,7 +99,7 @@ class BoundWidget:\n     ...\n     def id_for_label(self):\n         return self.data['attrs'].get('id', 'id_%s_%s' % (self.data['name'], self.data['index']))\n```", "model_name_or_path": "model-2"}, {"instance_id": "django__django-15252", "model_patch": "```diff\ndiff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py\n--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -63,7 +63,8 @@ class MigrationRecorder:\n         # Ensure the schema is there before anything else.\n         self.ensure_schema()\n \n         # Record the migration as applied.\n-        with schema_editor.connection.schema_editor() as schema_editor:\n+        if self.connection.schema_editor().has_table(self.MIGRATION_TABLE):\n+            with schema_editor.connection.schema_editor() as schema_editor:\n             schema_editor.execute(\n                 'INSERT INTO %s (%s, %s) VALUES (%%s, %%s)' % (\n                     self.MIGRATION_TABLE,\n                     'app',\n                     'name',\n                 ),\n                 [app_label, migration_name],\n             )\n\ndiff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -57,12 +57,12 @@ def test_custom_test_name_with_test_prefix(self):\n @mock.patch.object(connection, 'ensure_connection')\n @mock.patch.object(connection, 'prepare_database')\n @mock.patch('django.db.migrations.recorder.MigrationRecorder.has_table', return_value=False)\n-@mock.patch('django.db.migrations.executor.MigrationExecutor.migrate')\n @mock.patch('django.core.management.commands.migrate.Command.sync_apps')\n class TestDbCreationTests(SimpleTestCase):\n     available_apps = ['backends.base.app_unmigrated']\n \n-    def test_migrate_test_setting_false(self, mocked_sync_apps, mocked_migrate, *mocked_objects):\n+    @mock.patch('django.db.migrations.executor.MigrationExecutor.migrate')\n+    def test_migrate_test_setting_false(self, mocked_migrate, mocked_sync_apps, *mocked_objects):\n         test_connection = get_connection_copy()\n         test_connection.settings_dict['TEST']['MIGRATE'] = False\n         creation = test_connection.creation_class(test_connection)\n@@ -86,7 +86,32 @@ def test_migrate_test_setting_false(self, mocked_sync_apps, mocked_migrate, *moc\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n \n-    def test_migrate_test_setting_true(self, mocked_sync_apps, mocked_migrate, *mocked_objects):\n+    @mock.patch('django.db.migrations.executor.MigrationRecorder.ensure_schema')\n+    def test_migrate_test_setting_false_ensure_schema(\n+        self, mocked_ensure_schema, mocked_sync_apps, *mocked_objects,\n+    ):\n+        test_connection = get_connection_copy()\n+        test_connection.settings_dict['TEST']['MIGRATE'] = False\n+        creation = test_connection.creation_class(test_connection)\n+        if connection.vendor == 'oracle':\n+            # Don't close connection on Oracle.\n+            creation.connection.close = mock.Mock()\n+        old_database_name = test_connection.settings_dict['NAME']\n+        try:\n+            with mock.patch.object(creation, '_create_test_db'):\n+                creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)\n+            # The django_migrations table is not created.\n+            mocked_ensure_schema.assert_not_called()\n+            # App is synced.\n+            mocked_sync_apps.assert_called()\n+            mocked_args, _ = mocked_sync_apps.call_args\n+            self.assertEqual(mocked_args[1], {'app_unmigrated'})\n+        finally:\n+            with mock.patch.object(creation, '_destroy_test_db'):\n+                creation.destroy_test_db(old_database_name, verbosity=0)\n+\n+    @mock.patch('django.db.migrations.executor.MigrationExecutor.migrate')\n+    def test_migrate_test_setting_true(self, mocked_migrate, mocked_sync_apps, *mocked_objects):\n         test_connection = get_connection_copy()\n         test_connection.settings_dict['TEST']['MIGRATE'] = True\n         creation = test_connection.creation_class(test_connection)\n@@ -109,6 +134,7 @@ def test_migrate_test_setting_true(self, mocked_sync_apps, mocked_migrate, *mock\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n \n     @mock.patch.dict(os.environ, {'RUNNING_DJANGOS_TEST_SUITE': ''})\n+    @mock.patch('django.db.migrations.executor.MigrationExecutor.migrate')\n     @mock.patch.object(BaseDatabaseCreation, 'mark_expected_failures_and_skips')\n     def test_mark_expected_failures_and_skips_call(self, mark_expected_failures_and_skips, *mocked_objects):\n         \"\"\"\ndiff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py\n--- a/tests/migrations/test_executor.py\n+++ b/tests/migrations/test_executor.py\n@@ -759,6 +759,17 @@ def apply(self, project_state, schema_editor, collect_sql=False):\n             False,\n         )\n \n+    @mock.patch.object(MigrationRecorder, 'has_table', return_value=False)\n+    def test_migrate_skips_schema_creation(self, mocked_has_table):\n+        \"\"\"\n+        The django_migrations table is not created if there are no migrations\n+        to record.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        # 0 queries, since the query for has_table is being mocked.\n+        with self.assertNumQueries(0):\n+            executor.migrate([], plan=[])\n+\n \n class FakeLoader:\n     def __init__(self, graph, applied):\n```", "model_name_or_path": "model-2"}, {"instance_id": "matplotlib__matplotlib-24334", "model_patch": "```diff\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1020,6 +1020,22 @@\n         self._update_ticks()\n \n     def set_ticks(self, ticks, **kwargs):\n+        if not kwargs.get('labels') and any(k for k in kwargs):\n+            raise ValueError(\"kwargs are not allowed without labels.\")\n+\n         self._ticks = ticks\n         self._set_ticks(ticks, **kwargs)\n```\n", "model_name_or_path": "model-2"}, {"instance_id": "sphinx-doc__sphinx-7738", "model_patch": "```diff\ndiff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -123,6 +123,7 @@\n \n class NumpyDocstring(Docstring):\n     def __init__(self, docstring: str, config, app, objtype: str):\n+        self.strip_signature_backslash = getattr(config, 'strip_signature_backslash', False)\n         super().__init__(docstring, config, app, objtype)\n \n     def _parse_attributes(self):\n@@ -151,7 +152,9 @@\n             name = name.strip()\n             if self.strip_signature_backslash and name.endswith('_'):\n                 name = name[:-1]\n-            attributes[name] = (attr_type, desc)\n+            attributes[name.replace('\\\\_', '_')] = (attr_type, desc)\n+            if self.strip_signature_backslash:\n+                attributes[name] = (attr_type, desc)\n \n         return attributes\n```", "model_name_or_path": "model-2"}, {"instance_id": "sympy__sympy-13043", "model_patch": "```diff\ndiff --git a/sympy/integrals/tests/test_intpoly.py b/sympy/integrals/tests/test_intpoly.py\n--- a/sympy/integrals/tests/test_intpoly.py\n+++ b/sympy/integrals/tests/test_intpoly.py\n@@ -26,15 +26,15 @@ def test_decompose():\n     assert decompose(9*x**2 + y + 4*x + x**3 + y**2*x + 3) ==\\\n         {0: 3, 1: 4*x + y, 2: 9*x**2, 3: x**3 + x*y**2}\n \n-    assert decompose(x, True) == [x]\n-    assert decompose(x ** 2, True) == [x ** 2]\n-    assert decompose(x * y, True) == [x * y]\n-    assert decompose(x + y, True) == [x, y]\n-    assert decompose(x ** 2 + y, True) == [y, x ** 2]\n-    assert decompose(8 * x ** 2 + 4 * y + 7, True) == [7, 4*y, 8*x**2]\n-    assert decompose(x ** 2 + 3 * y * x, True) == [x ** 2, 3 * x * y]\n+    assert decompose(x, True) == {x}\n+    assert decompose(x ** 2, True) == {x**2}\n+    assert decompose(x * y, True) == {x * y}\n+    assert decompose(x + y, True) == {x, y}\n+    assert decompose(x ** 2 + y, True) == {y, x ** 2}\n+    assert decompose(8 * x ** 2 + 4 * y + 7, True) == {7, 4*y, 8*x**2}\n+    assert decompose(x ** 2 + 3 * y * x, True) == {x ** 2, 3 * x * y}\n     assert decompose(9 * x ** 2 + y + 4 * x + x ** 3 + y ** 2 * x + 3, True) == \\\n-           [3, y, x**3, 4*x, 9*x**2, x*y**2]\n+           {3, y, 4*x, 9*x**2, x*y**2, x**3}\n```", "model_name_or_path": "model-2"}, {"instance_id": "sympy__sympy-22714", "model_patch": "```diff\ndiff --git a/sympy/core/sympify.py b/sympy/core/sympify.py\nindex 12c4101f71..d7baf5b264 100644\n--- a/sympy/core/sympify.py\n+++ b/sympy/core/sympify.py\n@@ -469,7 +469,7 @@ def sympify(a, locals=None, evaluate=True):\n     # to get around the limitations of __new__ in some cases\n     if isinstance(a, str):\n         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n-    elif evaluate:\n+    elif evaluate and not isinstance(a, Point):\n         expr = eval_expr(a, local_dict, global_dict)\n     else:\n         expr = a\n```", "model_name_or_path": "model-2"}]